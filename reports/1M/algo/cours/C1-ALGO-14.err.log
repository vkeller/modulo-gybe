Traceback (most recent call last):
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.11/asyncio/base_events.py", line 653, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/vkeller/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# -------------------------------------------------------------
# G√©n√©rateur de mots al√©atoires de X lettres (x est la longueur)
# Vincent Keller, Gymnase de Beaulieu, (c) 2026
# -------------------------------------------------------------
import random

longueur = 7
taille_population = 100 # Doit √™tre pair !
generations = 30
taux_mutation = 1 # Compris entre 1 et 6 (d√© √† jouer)
alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def init_individu():
    j = 0
    mot = ""
    while j < longueur:
        pos = random.randint(1,26)
        mot = mot + alphabet[pos-1]
        j = j + 1
    return mot

def fitness(individu,cible):
    i = 0
    fit = 0
    while i < len(individu):
        if individu[i] == cible[i]:
            fit = fit + 1
        i = i + 1
    return fit

def selection(pop,cible):
    i = 0
    fit_pop = []
    sel_pop = []
    while i < len(pop):
        ind = [pop[i],fitness(pop[i],cible)]
        fit_pop.append(ind)
        i = i + 1
    i = 0
    # Tri de la liste en fonction des fitness
    fit_pop = sorted(fit_pop,key=lambda x: x[1])
    i = taille_population - 1
    while i >= 0:
        sel_pop.append(fit_pop[i][0])
        i = i - 1
    # Renvoi d'une liste de taille taille_population (les taille_population plus forts)
    return sel_pop

def crossover(ind1,ind2):
    new_ind1 = ""
    new_ind2 = ""
    i = 0
    # Point de mutation (pour le jeu, 1 √† 6 fonctionne)
    point = random.randint(1,longueur)
    while i < len(ind1):
        if i < point:
            new_ind1 = new_ind1 + ind1[i]
            new_ind2 = new_ind2 + ind2[i]
        else:
            new_ind1 = new_ind1 + ind2[i]
            new_ind2 = new_ind2 + ind1[i]
        i = i + 1
    return new_ind1, new_ind2

def mutation(ind):
    point = random.randint(1,longueur)
    new_ind = ""
    i = 0
    while i < longueur:
        if i == point:
            pos = random.randint(1,26)
            new_ind = new_ind + alphabet[pos-1]
        else:
            new_ind = new_ind + ind[i]
        i = i + 1
    return new_ind

## INITIALISATION
population = []
i = 0
while i < taille_population:
    population.append(init_individu())
    i = i + 1

secret = input("Quel mot √† rechercher : ")
secret = secret.upper()

#variable permettant de savoir si l'algorithme a converg√©
trouve = False

## GENERATIONS
g = 0
while g < generations:
    ## SELECTION
    sel = selection(population, secret)
    fit_max = 0

    ## CROSSOVER
    i = 0
    while i < taille_population:
        ind1, ind2 = crossover(sel[i], sel[i+1])
        sel[i] = ind1
        sel[i + 1] = ind2
        i = i + 2
        
    ## MUTATION
    i = 0
    while i < taille_population:
        mut = random.randint(1,6)
        if mut < taux_mutation :
            sel[i] = mutation(sel[i])
        i = i + 1
    # A-T-ON TROUVE LE SECRET ?
    i = 0
    while i < taille_population:
        fit = fitness(sel[i], secret)
        #print(sel[i],fit)
        if fit == longueur:
            print("Mot secret trouv√© : ",sel[i],"√† la g√©n√©ration",g)
            # permet de sortir de la boucle
            trouve = True
            g = generations + 1
            i = taille_population + 1
        i = i + 1
    ## RECOPIE DE LA POP SEL VERS LA POPULATION
    population.clear()
    population = sel.copy()
    sel.clear()
    g = g + 1

if trouve == False:
    print("L'algorithme n'a pas trouv√© de solution")

------------------


[31m---------------------------------------------------------------------------[39m
[31mStdinNotImplementedError[39m                  Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[2][39m[32m, line 85[39m
[32m     82[39m     population.append(init_individu())
[32m     83[39m     i = i + [32m1[39m
[32m---> [39m[32m85[39m secret = [38;5;28;43minput[39;49m[43m([49m[33;43m"[39;49m[33;43mQuel mot √† rechercher : [39;49m[33;43m"[39;49m[43m)[49m
[32m     86[39m secret = secret.upper()
[32m     88[39m [38;5;66;03m#variable permettant de savoir si l'algorithme a converg√©[39;00m

[36mFile [39m[32m~/.local/pipx/venvs/jupyter-book/lib/python3.11/site-packages/ipykernel/kernelbase.py:1274[39m, in [36mKernel.raw_input[39m[34m(self, prompt)[39m
[32m   1272[39m [38;5;28;01mif[39;00m [38;5;129;01mnot[39;00m [38;5;28mself[39m._allow_stdin:
[32m   1273[39m     msg = [33m"[39m[33mraw_input was called, but this frontend does not support input requests.[39m[33m"[39m
[32m-> [39m[32m1274[39m     [38;5;28;01mraise[39;00m StdinNotImplementedError(msg)
[32m   1275[39m [38;5;28;01mreturn[39;00m [38;5;28mself[39m._input_request(
[32m   1276[39m     [38;5;28mstr[39m(prompt),
[32m   1277[39m     [38;5;28mself[39m._parent_ident[[33m"[39m[33mshell[39m[33m"[39m],
[32m   1278[39m     [38;5;28mself[39m.get_parent([33m"[39m[33mshell[39m[33m"[39m),
[32m   1279[39m     password=[38;5;28;01mFalse[39;00m,
[32m   1280[39m )

[31mStdinNotImplementedError[39m: raw_input was called, but this frontend does not support input requests.

